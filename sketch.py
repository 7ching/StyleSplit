# -*- coding: utf-8 -*-
"""sketch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19O7EdUT8cQqhNyTKCOuhRjOjSihdeFEr
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

# 1. 讀取輸入影像
img = cv2.imread('input10.jpg')
if img is None:
    raise FileNotFoundError("請確認 'input.jpg' 存在於工作目錄中")

# img = cv2.resize(img, (0, 0), fx=0.3, fy=0.3)

# 2. 使用 GrabCut 自動分割前景（主體）和背景
mask = np.zeros(img.shape[:2], np.uint8)
rect = (10, 10, img.shape[1] - 20, img.shape[0] - 20)  # 初始化矩形：去除邊界
bgdModel = np.zeros((1, 65), np.float64)
fgdModel = np.zeros((1, 65), np.float64)
cv2.grabCut(img, mask, rect, bgdModel, fgdModel, 5, cv2.GC_INIT_WITH_RECT)

# 將 GrabCut 標記轉為二值前景遮罩
mask2 = np.where((mask == 2) | (mask == 0), 0, 1).astype('uint8')

# 讀圖 + 灰階
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (7, 7), 0)

# Laplacian 邊緣偵測（或改用 Sobel）
edges = cv2.Laplacian(gray, cv2.CV_8U, ksize=5)
edges = cv2.GaussianBlur(edges, (5, 5), 0)

# 反轉邊緣圖像，讓線條是黑的，背景白
inv = 255 - edges
light_shade = 255 - gray
sketch = cv2.addWeighted(inv, 0.4, light_shade, 0.6, 0)

# 可以加強對比（optional）
sketch = cv2.normalize(sketch, None, 0, 255, cv2.NORM_MINMAX)
# _, sketch = cv2.threshold(sketch, 100, 255, cv2.THRESH_BINARY)
texture = cv2.imread('paper.jpg', cv2.IMREAD_GRAYSCALE)
texture = cv2.resize(texture, (sketch.shape[1], sketch.shape[0]))
sketch = cv2.multiply(sketch, texture, scale=1/255)
sketch_color = cv2.cvtColor(sketch, cv2.COLOR_GRAY2BGR)

# 儲存與顯示
cv2.imwrite('sketch_effect.jpg', sketch)
plt.imshow(sketch, cmap='gray')
plt.axis('off')
plt.show()

# 4. 對背景應用油畫效果
oil = cv2.stylization(img, sigma_s=60, sigma_r=0.6)

# 5. 合併：前景使用素描風，背景使用油畫風
combined = np.where(mask2[:, :, None] == 1, sketch_color, oil)

# 6. 儲存並顯示結果
cv2.imwrite('output.jpg', combined)
plt.figure(figsize=(8, 6))
plt.imshow(cv2.cvtColor(combined, cv2.COLOR_BGR2RGB))
plt.axis('off')
plt.title("前景素描 + 背景油畫 效果")
plt.show()